/**
 * Possibly Unused i18n Token Finder
 * Key word: POSSIBLY
 *
 * Looks for i18n tokens that MAY be unused by the code
 * Since some tokens are generated dynamically, the list generated by this script
 * should ALWAYS be verified manually before removing any of the tokens in it
 *
 * Ghostery i18n Tools
 * http://www.ghostery.com/
 *
 * Copyright 2019 Ghostery, Inc. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0
 */

console.time('unused-i18n-token-finder');

const fs = require('fs');
const jsonfile = require('jsonfile');

// Constants
const CONFIG_FILE = 'config.json';
const RESULTS_DIR = './results';
const RESULTS_FILENAME = 'unused_tokens.txt';

function makeDirIfNeeded(path) {
	if (!fs.existsSync(path)) { fs.mkdirSync(path); }
}

function writeResultsToDisk(project, unusedTokens) {
	const filepath = `${RESULTS_DIR}/${project}/${RESULTS_FILENAME}`;

	makeDirIfNeeded(RESULTS_DIR);
	makeDirIfNeeded(`${RESULTS_DIR}/${project}`);

	fs.writeFileSync(
		filepath,
		unusedTokens.join('\n')
	);
}

function findUnusedTokens(tokens, filepaths) {
	tokens = tokens.map(token => ({ value: token, isUsed: false }));

	filepaths.forEach((filepath) => {
		const fileContents = fs.readFileSync(filepath, 'utf8');
		tokens.forEach((token) => {
			if (token.isUsed) { return; }

			// THE TEST
			if (fileContents.includes(`t('${token.value}`)) {
				token.isUsed = true;
			}
		});
	});

	const unusedTokens =
		(tokens.filter(token => token.isUsed === false))
			.map(token => token.value);

	return unusedTokens;
}

/**
 * Recursively collect the filepaths of files that
 * satisfy the supplied extension and file system location conditions
 * @param [Array|object] whereToLookAndForWhatExtensions
 * @param [string Array] filepaths							The matching filepaths
 * @returns [string Array] filepaths						The matching filepaths
 */
function loadFilepaths(root, locationsAndExtensions, filepaths = []) {
	const target = locationsAndExtensions;

	if (Array.isArray(target)) {
		locationsAndExtensions.forEach((locationAndExtensions) => {
			filepaths = loadFilepaths(root, locationAndExtensions, filepaths);
		});
	} else {
		const dirEntries = fs.readdirSync(`${root}/${target.dir}`, { withFileTypes: true });

		dirEntries.forEach((dirEntry) => {
			if (dirEntry.isDirectory()) {
				filepaths = loadFilepaths(
					root,
					{
						dir: `${target.dir}/${dirEntry.name}`,
						extensions: target.extensions
					},
					filepaths
				);
			} else if (dirEntry.isFile()) {
				if (target.extensions.some(extension => dirEntry.name.endsWith(extension))) {
					filepaths.push(`${root}/${target.dir}/${dirEntry.name}`);
				}
			}
		});
	}

	return filepaths;
}

function loadTokens(project) {
	const messages = jsonfile.readFileSync(`${project.root}/${project.default_locale_filepath}`, {throws: false});

	if (messages === null) {
		bail(`The default locale json file for the '${project.name}' project is missing or invalid.\nCheck the project's 'root' and 'default_locale_filepath' values and the file's syntax.`);
	}

	return Object.keys(messages);
}

function validateConfig(configJson) {
	if (configJson === null) {
		bail(`The config file at\n  ${process.cwd()}/${configFile}\nis missing or invalid.\nPlease check config file location, name, and syntax.`);
	}

	if (
		!Array.isArray(configJson["target_projects"])
		|| configJson["target_projects"].length === 0
	) {
		bail("The 'target_projects' array in the config file is undefined or empty.\nFill it with the names of the projects you want to process and try again.");
	}

	if (configJson["projects"] === undefined) {
		bail("The 'projects' object in the config file is undefined.\nFill it with the details of the projects you want to process and try again.")
	}

	configJson["target_projects"].forEach((name) => {
		if (configJson["projects"][name] === undefined) {
			bail(`The '${name}' target project is not defined in the config file.\nDefine it and try again.`);
		}
	})
}

function getProjects(configFile) {
	const configJson = jsonfile.readFileSync(`${process.cwd()}/${configFile}`, {throws: false});

	validateConfig(configJson);

	const projects = [];
	configJson["target_projects"].forEach((projectName) => {
		const targetProject = configJson["projects"][projectName];
		targetProject.name = projectName;
		projects.push(targetProject);
	});

	return projects;
}

function bail(message) {
	console.error(`\n${message}`);
	console.error("\nExiting...");

	process.exit();
}

const projects = getProjects(CONFIG_FILE);
projects.forEach((project) => {
	const tokens = loadTokens(project);
	const filepaths = loadFilepaths(project.root, project.search_filepaths);
	const unusedTokens = findUnusedTokens(tokens, filepaths);
	writeResultsToDisk(project.name, unusedTokens);
});

console.log('\nPLEASE NOTE:');
console.log('Since some i18n tokens are generated dynamically,')
console.log('and since some others are formatted in a non-standard way,');
console.log('the lists generated by this script should ALWAYS');
console.log('be verified manually before removing any of the tokens in them.');
console.log('\nThe results are in ./results/[project]/unused_tokens.txt\n');

console.timeEnd('unused-i18n-token-finder');
