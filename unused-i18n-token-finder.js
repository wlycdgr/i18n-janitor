/**
 * Possibly Unused i18n Token Finder
 * Key word: POSSIBLY
 *
 * Looks for i18n tokens that MAY be unused by the code
 * Since some tokens are generated dynamically, the list generated by this script
 * should ALWAYS be verified manually before removing any of the tokens in it
 *
 * Ghostery Browser Extension
 * http://www.ghostery.com/
 *
 * Copyright 2019 Ghostery, Inc. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0
 */

console.time('unused-i18n-token-finder');

// eslint-disable-next-line import/no-extraneous-dependencies
const fs = require('fs');
// eslint-disable-next-line import/no-extraneous-dependencies
const jsonfile = require('jsonfile');

// Constants
const CONFIG_FILE = 'config.json';
const DEFAULT_LOCALE_TOKENS_FILE = '/_locales/en/messages.json';
const RESULTS_DIR = './results';
const UNUSED_TOKENS_RESULTS_FILENAME = 'unused_tokens.txt';

function saveListOfUnusedTokensToFile(unusedTokens) {
	const filepath = `${RESULTS_DIR}/${UNUSED_TOKENS_RESULTS_FILENAME}`;

	if (!fs.existsSync(RESULTS_DIR)) {
		fs.mkdirSync(RESULTS_DIR);
	}

	fs.writeFileSync(
		filepath,
		unusedTokens.join('\n')
	);
}

function findUnusedTokens(tokens, filepaths) {
	tokens = tokens.map(token => ({ value: token, isUsed: false }));

	filepaths.forEach((filepath) => {
		const fileContents = fs.readFileSync(filepath, 'utf8');
		tokens.forEach((token) => {
			if (token.isUsed) { return; }

			// THE TEST
			if (fileContents.includes(`t('${token.value}`)) {
				token.isUsed = true;
			}
		});
	});

	const unusedTokens =
		(tokens.filter(token => token.isUsed === false))
			.map(token => token.value);

	return unusedTokens;
}

/**
 * Recursively collect the filepaths of files that
 * satisfy the supplied extension and file system location conditions
 * @param [Array|object] whereToLookAndForWhatExtensions
 * @param [string Array] filepaths							The matching filepaths
 * @returns [string Array] filepaths						The matching filepaths
 */
function getFilepaths(whereToLookAndForWhatExtensions, filepaths = []) {
	const target = whereToLookAndForWhatExtensions;

	if (Array.isArray(target)) {
		target.forEach((t) => {
			filepaths = getFilepaths(t, filepaths);
		});
	} else {
		const dirEntries = fs.readdirSync(target.dir, { withFileTypes: true });

		dirEntries.forEach((dirEntry) => {
			if (dirEntry.isDirectory()) {
				filepaths = getFilepaths({
					dir: `${target.dir}/${dirEntry.name}`,
					extensions: target.extensions
				}, filepaths);
			} else if (dirEntry.isFile()) {
				if (target.extensions.some(extension => dirEntry.name.endsWith(extension))) {
					filepaths.push(`${target.dir}/${dirEntry.name}`);
				}
			}
		});
	}

	return filepaths;
}

function getJSONKeys(filepath) {
	const json = jsonfile.readFileSync(filepath);
	return Object.keys(json);
}


function loadTargetProjectsConfig(configFilePath) {
	return new Promise(resolve => {
		const configJson = jsonfile.readFileSync(configFilePath);
		resolve(configJson);
	});
}

function findUnused(targets) {
	console.log(targets);
}

function parseConfig(jsonConfig) {
	console.log(jsonConfig);
}

function loadAndParseConfig(configFile) {
	const jsonConfig = jsonfile.readFileSync(`${process.cwd()}/${configFile}`, {throws: false});

	if (jsonConfig === null) {
		bail(`The config file at\n  ${process.cwd()}/${configFile}\nis missing or invalid.\nPlease check config file location, name, and syntax.`);
	}

	if (
		!Array.isArray(jsonConfig["target_projects"])
		|| jsonConfig["target_projects"].length === 0
	) {
		bail("The 'target_projects' array in the config file is undefined or empty.\nFill it with the names of the projects you want to process and try again.");
	}

	if (jsonConfig["projects"] === undefined) {
		bail("The 'projects' object in the config file is undefined.\nFill it with the details of the projects you want to process and try again.")
	}

	const targets = [];
	jsonConfig["target_projects"].forEach((name) => {
		const targetProject = jsonConfig["projects"][name];
		if (targetProject === undefined) {
			bail(`The '${name}' target project is not defined in the config file.\nDefine it and try again.`);
		}
		targets.push(targetProject);
	});

	return targets;
}

function bail(message) {
	console.log(`\n${message}`);
	console.log("\nExiting...");

	process.exit();
}

//loadConfig(CONFIG_FILE);
const targets = loadAndParseConfig(CONFIG_FILE);
// const tokens = getTokens(targets);
// const tokens = getTokens(targets);
// const filepaths = getFilepaths(targets);
// const unusedTokens = findUnusedTokens(tokens, filepaths);
// writeResultsToDisk(unusedTokens);
//
//
// console.log('\nPLEASE NOTE:');
// console.log('Since some i18n tokens are generated dynamically,')
// console.log('and since some others are formatted in a non-standard way,');
// console.log('the list generated by this script should ALWAYS');
// console.log('be verified manually before removing any of the tokens in it.');
// console.log('\nThe results are in ./tools/i18n_results/unused_tokens.txt\n');

console.timeEnd('unused-i18n-token-finder');
